print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = y_tPlus1_simulation,
input_title = 'Bayesian prediction for y_T+1 using AR(2) model under the non-informative prior',
input_path = 'figures/c_hist.png')
numberOfSimulations <- 10000
this_y <- c(1, last_row$`y_t`, last_row$`y_lag1`)
hat_beta <- coef(ar2_gdp)
covarianceMatrix <- ar2_estimation$cov.unscaled
degreeOfFreedom <- ar2_estimation$df[2]
sizeOfSample <- length(raw[['time']])
y_tPlus1_simulation <- numeric(numberOfSimulations)
for (i in 1:numberOfSimulations){
beta_i <- rmvt(n = 1,
sigma = covarianceMatrix,
df = degreeOfFreedom,
delta = hat_beta, type = 'shifted')
beta_i <- as.numeric(beta_i)        # length p
beta_i <- matrix(beta_i, ncol = 1)
y <- raw[['y_t']]
X <- model.matrix(ar2_gdp)
residual <- y - X %*% beta_i
this_scale <- 1/(1/2 * t(residual) %*% residual)
h_i <- rgamma(n = 1, shape = sizeOfSample/2 , scale = this_scale)
residuals_i <- rnorm(n = 1, mean = 0, sd = sqrt(1/h_i))
this_hat_y_tPlus1 <- sum(this_y * hat_beta)
y_tPlus1_simulation[i] <- this_hat_y_tPlus1 + residuals_i
}
distributionPlot <- function(input_x, input_title, input_path){
plot_df <- data.frame(x = seq_along(input_x), y = input_x)
ggplot(plot_df, aes(x = y)) +
geom_histogram(aes(y = after_stat(density)),
bins = 50, fill = 'skyblue', color = 'blue') +
labs(title = input_title,
x = 'y_T+1', y = 'Density') +
theme_minimal()
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
bayesian_mean <- mean(y_tPlus1_simulation)
bayesian_95_lowerBound <- quantile(y_tPlus1_simulation, 0.025)
bayesian_95_upperBound<- quantile(y_tPlus1_simulation, 0.975)
print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = y_tPlus1_simulation,
input_title = 'Bayesian prediction for y_T+1 using AR(2) model under the non-informative prior',
input_path = 'figures/c_hist.png')
t_prior <- raw[1:10,]
ar2_prior <- lm(formula = y_t ~ `y_lag1` + `y_lag2`,
data = t_prior)
ar2_prior_estimation <- summary(ar2_prior)
computeStudenttDensity <- function(input_x, input_m, input_c,input_DoF){
firstPart <- gamma((input_DoF+1)/2) / (gamma(input_DoF/2)*sqrt(input_DoF*pi))
secondPart <- 1 / input_c
thirdPart <- (1 + 1/input_DoF * (input_x-input_m)^2 / input_c^2) ^ -((input_DoF+1)/2)
density <- firstPart * secondPart * thirdPart
}
prior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_prior$coefficients[3],
input_c = ar2_prior_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_prior$df.residual)
posterior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_gdp$coefficients[3],
input_c = ar2_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_gdp$df.residual)
posteriorOddsRatio <- prior_density / posterior_density
ar1_probability <- posteriorOddsRatio / (1+posteriorOddsRatio)
ar2_probability <- 1 / (1+posteriorOddsRatio)
ar_simulation <- function(input_numberOfSimulations,
input_y,
input_model,
input_modelEstimation){
hat_beta <- coef(input_model)
covarianceMatrix <- input_modelEstimation$cov.unscaled
degreeOfFreedom <- input_model$df.residual
sizeOfSample <- length(input_model$model[['y_t']])
y_tPlus1_simulation <- numeric(input_numberOfSimulations)
for (i in 1:input_numberOfSimulations){
beta_i <- rmvt(n = 1,
sigma = covarianceMatrix,
df = degreeOfFreedom,
delta = hat_beta, type = 'shifted')
beta_i <- as.numeric(beta_i)        # length p
beta_i <- matrix(beta_i, ncol = 1)
y <- input_model$model[['y_t']]
X <- model.matrix(input_model)
residual <- y - X %*% beta_i
this_scale <- 1/(1/2 * t(residual) %*% residual)
h_i <- rgamma(n = 1, shape = sizeOfSample/2 , scale = this_scale)
residuals_i <- rnorm(n = 1, mean = 0, sd = sqrt(1/h_i))
this_hat_y_tPlus1 <- sum(input_y * hat_beta)
y_tPlus1_simulation[i] <- this_hat_y_tPlus1 + residuals_i
}
return(y_tPlus1_simulation)
}
ar1_numberOfSimulations <- ar1_probability * numberOfSimulations
ar2_numberOfSimulations <- ar2_probability * numberOfSimulations
ar1_result <- ar_simulation(
input_numberOfSimulations = ar1_numberOfSimulations,
input_y = this_y,
input_model = ar2_prior,
input_modelEstimation = ar2_prior_estimation)
ar2_result <- ar_simulation(
input_numberOfSimulations = ar2_numberOfSimulations,
input_y = this_y,
input_model = ar2_gdp,
input_modelEstimation = ar2_estimation)
BMA_simulationResults <- c(ar1_result, ar2_result)
bayesian_mean <- mean(BMA_simulationResults)
bayesian_95_lowerBound <- quantile(BMA_simulationResults, 0.025)
bayesian_95_upperBound<- quantile(BMA_simulationResults, 0.975)
print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = BMA_simulationResults,
input_title = 'Bayesian prediction for y_T+1 using Bayesian Model Averaging (BMA) with the AR(1) and AR(2) models',
input_path = 'figures/d_hist.png')
t_prior <- raw[1:10,]
ar2_prior <- lm(formula = y_t ~ `y_lag1` + `y_lag2`,
data = t_prior)
ar2_prior_estimation <- summary(ar2_prior)
computeStudenttDensity <- function(input_x, input_m, input_c,input_DoF){
firstPart <- gamma((input_DoF+1)/2) / (gamma(input_DoF/2)*sqrt(input_DoF*pi))
secondPart <- 1 / input_c
thirdPart <- (1 + 1/input_DoF * (input_x-input_m)^2 / input_c^2) ^ -((input_DoF+1)/2)
density <- firstPart * secondPart * thirdPart
}
prior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_prior$coefficients[3],
input_c = ar2_prior_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_prior$df.residual)
posterior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_gdp$coefficients[3],
input_c = ar2_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_gdp$df.residual)
posteriorOddsRatio <- prior_density / posterior_density
ar1_probability <- posteriorOddsRatio / (1+posteriorOddsRatio)
ar2_probability <- 1 / (1+posteriorOddsRatio)
ar_simulation <- function(input_numberOfSimulations,
input_y,
input_model,
input_modelEstimation){
hat_beta <- coef(input_model)
covarianceMatrix <- input_modelEstimation$cov.unscaled
degreeOfFreedom <- input_model$df.residual
sizeOfSample <- length(input_model$model[['y_t']])
y_tPlus1_simulation <- numeric(input_numberOfSimulations)
for (i in 1:input_numberOfSimulations){
beta_i <- rmvt(n = 1,
sigma = covarianceMatrix,
df = degreeOfFreedom,
delta = hat_beta, type = 'shifted')
beta_i <- as.numeric(beta_i)        # length p
beta_i <- matrix(beta_i, ncol = 1)
y <- input_model$model[['y_t']]
X <- model.matrix(input_model)
residual <- y - X %*% beta_i
this_scale <- 1/(1/2 * t(residual) %*% residual)
h_i <- rgamma(n = 1, shape = sizeOfSample/2 , scale = this_scale)
residuals_i <- rnorm(n = 1, mean = 0, sd = sqrt(1/h_i))
this_hat_y_tPlus1 <- sum(input_y * hat_beta)
y_tPlus1_simulation[i] <- this_hat_y_tPlus1 + residuals_i
}
return(y_tPlus1_simulation)
}
ar1_numberOfSimulations <- ar1_probability * numberOfSimulations
ar2_numberOfSimulations <- ar2_probability * numberOfSimulations
SDDR_df <- data.frame(Model = c('AR(1)','AR(2)'),
Density = c(prior_density,posterior_density),
Probability = c(ar1_probability,ar2_probability),
numberOfSimulations = c(ar1_numberOfSimulations, ar2_numberOfSimulations),
posteriorOddsRatio = posteriorOddsRatio)
ar1_result <- ar_simulation(
input_numberOfSimulations = ar1_numberOfSimulations,
input_y = this_y,
input_model = ar2_prior,
input_modelEstimation = ar2_prior_estimation)
ar2_result <- ar_simulation(
input_numberOfSimulations = ar2_numberOfSimulations,
input_y = this_y,
input_model = ar2_gdp,
input_modelEstimation = ar2_estimation)
BMA_simulationResults <- c(ar1_result, ar2_result)
bayesian_mean <- mean(BMA_simulationResults)
bayesian_95_lowerBound <- quantile(BMA_simulationResults, 0.025)
bayesian_95_upperBound<- quantile(BMA_simulationResults, 0.975)
print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = BMA_simulationResults,
input_title = 'Bayesian prediction for y_T+1 using Bayesian Model Averaging (BMA) with the AR(1) and AR(2) models',
input_path = 'figures/d_hist.png')
t_prior <- raw[1:10,]
ar2_prior <- lm(formula = y_t ~ `y_lag1` + `y_lag2`,
data = t_prior)
ar2_prior_estimation <- summary(ar2_prior)
computeStudenttDensity <- function(input_x, input_m, input_c,input_DoF){
firstPart <- gamma((input_DoF+1)/2) / (gamma(input_DoF/2)*sqrt(input_DoF*pi))
secondPart <- 1 / input_c
thirdPart <- (1 + 1/input_DoF * (input_x-input_m)^2 / input_c^2) ^ -((input_DoF+1)/2)
density <- firstPart * secondPart * thirdPart
}
prior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_prior$coefficients[3],
input_c = ar2_prior_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_prior$df.residual)
posterior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_gdp$coefficients[3],
input_c = ar2_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_gdp$df.residual)
posteriorOddsRatio <- prior_density / posterior_density
ar1_probability <- posteriorOddsRatio / (1+posteriorOddsRatio)
ar2_probability <- 1 / (1+posteriorOddsRatio)
ar_simulation <- function(input_numberOfSimulations,
input_y,
input_model,
input_modelEstimation){
hat_beta <- coef(input_model)
covarianceMatrix <- input_modelEstimation$cov.unscaled
degreeOfFreedom <- input_model$df.residual
sizeOfSample <- length(input_model$model[['y_t']])
y_tPlus1_simulation <- numeric(input_numberOfSimulations)
for (i in 1:input_numberOfSimulations){
beta_i <- rmvt(n = 1,
sigma = covarianceMatrix,
df = degreeOfFreedom,
delta = hat_beta, type = 'shifted')
beta_i <- as.numeric(beta_i)        # length p
beta_i <- matrix(beta_i, ncol = 1)
y <- input_model$model[['y_t']]
X <- model.matrix(input_model)
residual <- y - X %*% beta_i
this_scale <- 1/(1/2 * t(residual) %*% residual)
h_i <- rgamma(n = 1, shape = sizeOfSample/2 , scale = this_scale)
residuals_i <- rnorm(n = 1, mean = 0, sd = sqrt(1/h_i))
this_hat_y_tPlus1 <- sum(input_y * hat_beta)
y_tPlus1_simulation[i] <- this_hat_y_tPlus1 + residuals_i
}
return(y_tPlus1_simulation)
}
ar1_numberOfSimulations <- ar1_probability * numberOfSimulations
ar2_numberOfSimulations <- ar2_probability * numberOfSimulations
SDDR_df <- data.frame(Model = c('AR(1)','AR(2)'),
Density = c(prior_density,posterior_density),
Probability = c(ar1_probability,ar2_probability),
numberOfSimulations = c(ar1_numberOfSimulations, ar2_numberOfSimulations),
posteriorOddsRatio = posteriorOddsRatio)
SDDR_df
ar1_result <- ar_simulation(
input_numberOfSimulations = ar1_numberOfSimulations,
input_y = this_y,
input_model = ar2_prior,
input_modelEstimation = ar2_prior_estimation)
ar2_result <- ar_simulation(
input_numberOfSimulations = ar2_numberOfSimulations,
input_y = this_y,
input_model = ar2_gdp,
input_modelEstimation = ar2_estimation)
BMA_simulationResults <- c(ar1_result, ar2_result)
bayesian_mean <- mean(BMA_simulationResults)
bayesian_95_lowerBound <- quantile(BMA_simulationResults, 0.025)
bayesian_95_upperBound<- quantile(BMA_simulationResults, 0.975)
print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = BMA_simulationResults,
input_title = 'Bayesian prediction for y_T+1 using Bayesian Model Averaging (BMA) with the AR(1) and AR(2) models',
input_path = 'figures/d_hist.png')
t_prior <- raw[1:10,]
ar2_prior <- lm(formula = y_t ~ `y_lag1` + `y_lag2`,
data = t_prior)
ar2_prior_estimation <- summary(ar2_prior)
computeStudenttDensity <- function(input_x, input_m, input_c,input_DoF){
firstPart <- gamma((input_DoF+1)/2) / (gamma(input_DoF/2)*sqrt(input_DoF*pi))
secondPart <- 1 / input_c
thirdPart <- (1 + 1/input_DoF * (input_x-input_m)^2 / input_c^2) ^ -((input_DoF+1)/2)
density <- firstPart * secondPart * thirdPart
}
prior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_prior$coefficients[3],
input_c = ar2_prior_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_prior$df.residual)
posterior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_gdp$coefficients[3],
input_c = ar2_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_gdp$df.residual)
posteriorOddsRatio <- posterior_density / prior_density
ar1_probability <- posteriorOddsRatio / (1+posteriorOddsRatio)
ar2_probability <- 1 / (1+posteriorOddsRatio)
ar_simulation <- function(input_numberOfSimulations,
input_y,
input_model,
input_modelEstimation){
hat_beta <- coef(input_model)
covarianceMatrix <- input_modelEstimation$cov.unscaled
degreeOfFreedom <- input_model$df.residual
sizeOfSample <- length(input_model$model[['y_t']])
y_tPlus1_simulation <- numeric(input_numberOfSimulations)
for (i in 1:input_numberOfSimulations){
beta_i <- rmvt(n = 1,
sigma = covarianceMatrix,
df = degreeOfFreedom,
delta = hat_beta, type = 'shifted')
beta_i <- as.numeric(beta_i)        # length p
beta_i <- matrix(beta_i, ncol = 1)
y <- input_model$model[['y_t']]
X <- model.matrix(input_model)
residual <- y - X %*% beta_i
this_scale <- 1/(1/2 * t(residual) %*% residual)
h_i <- rgamma(n = 1, shape = sizeOfSample/2 , scale = this_scale)
residuals_i <- rnorm(n = 1, mean = 0, sd = sqrt(1/h_i))
this_hat_y_tPlus1 <- sum(input_y * hat_beta)
y_tPlus1_simulation[i] <- this_hat_y_tPlus1 + residuals_i
}
return(y_tPlus1_simulation)
}
ar1_numberOfSimulations <- ar1_probability * numberOfSimulations
ar2_numberOfSimulations <- ar2_probability * numberOfSimulations
SDDR_df <- data.frame(Model = c('AR(1)','AR(2)'),
Density = c(prior_density,posterior_density),
Probability = c(ar1_probability,ar2_probability),
numberOfSimulations = c(ar1_numberOfSimulations, ar2_numberOfSimulations),
posteriorOddsRatio = posteriorOddsRatio)
SDDR_df
ar1_result <- ar_simulation(
input_numberOfSimulations = ar1_numberOfSimulations,
input_y = this_y,
input_model = ar2_prior,
input_modelEstimation = ar2_prior_estimation)
ar2_result <- ar_simulation(
input_numberOfSimulations = ar2_numberOfSimulations,
input_y = this_y,
input_model = ar2_gdp,
input_modelEstimation = ar2_estimation)
BMA_simulationResults <- c(ar1_result, ar2_result)
bayesian_mean <- mean(BMA_simulationResults)
bayesian_95_lowerBound <- quantile(BMA_simulationResults, 0.025)
bayesian_95_upperBound<- quantile(BMA_simulationResults, 0.975)
print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = BMA_simulationResults,
input_title = 'Bayesian prediction for y_T+1 using Bayesian Model Averaging (BMA) with the AR(1) and AR(2) models',
input_path = 'figures/d_hist.png')
# Load required packages
library(openxlsx)   # Excel file handling
library(ggplot2)    # Data visualization
library(mvtnorm)    #
raw <- read.xlsx('Assignment4Dataset.xlsx', colNames = TRUE)
gdpPlot <- function (input_date, input_y, input_title, input_path){
plot_df <- data.frame(time = input_date, gdp_forecast = input_y)
ggplot(plot_df, aes(x = time)) +
geom_hline(yintercept = 0, color = 'black',
linewidth = 1, linetype = 'dashed') +
geom_line(aes(y = gdp_forecast), color = 'red',
linewidth = 1) +
labs(title = input_title,
x = 'Time', y = 'GDP') +
theme_minimal()
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
gdpPlot(raw[['time']], raw[['y_t']], 'Forecasting real US GDP growth using Autoregressive (AR) models', 'figures/a_gdp.png')
colnames(raw) <- c('time', 'y_t', 'y_lag1', 'y_lag2')
ar2_gdp <- lm(formula = y_t ~ `y_lag1` + `y_lag2`,
data = raw)
ar2_estimation <- summary(ar2_gdp)
last_row <- raw[nrow(raw),]
new_df <- data.frame(`y_lag1` = last_row$`y_t`,
`y_lag2` = last_row$`y_lag1`)
y_tPlus1 <- predict(ar2_gdp, newdata = new_df)
s <- ar2_estimation$sigma
y_tPlus1_95_lowerBound <- y_tPlus1 - 1.96*s
y_tPlus1_95_upperBound <- y_tPlus1 + 1.96*s
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', y_tPlus1))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
y_tPlus1_95_lowerBound,
y_tPlus1_95_upperBound))
numberOfSimulations <- 10000
this_y <- c(1, last_row$`y_t`, last_row$`y_lag1`)
hat_beta <- coef(ar2_gdp)
covarianceMatrix <- ar2_estimation$cov.unscaled
degreeOfFreedom <- ar2_estimation$df[2]
sizeOfSample <- length(raw[['time']])
y_tPlus1_simulation <- numeric(numberOfSimulations)
for (i in 1:numberOfSimulations){
beta_i <- rmvt(n = 1,
sigma = covarianceMatrix,
df = degreeOfFreedom,
delta = hat_beta, type = 'shifted')
beta_i <- as.numeric(beta_i)        # length p
beta_i <- matrix(beta_i, ncol = 1)
y <- raw[['y_t']]
X <- model.matrix(ar2_gdp)
residual <- y - X %*% beta_i
this_scale <- 1/(1/2 * t(residual) %*% residual)
h_i <- rgamma(n = 1, shape = sizeOfSample/2 , scale = this_scale)
residuals_i <- rnorm(n = 1, mean = 0, sd = sqrt(1/h_i))
this_hat_y_tPlus1 <- sum(this_y * hat_beta)
y_tPlus1_simulation[i] <- this_hat_y_tPlus1 + residuals_i
}
distributionPlot <- function(input_x, input_title, input_path){
plot_df <- data.frame(x = seq_along(input_x), y = input_x)
ggplot(plot_df, aes(x = y)) +
geom_histogram(aes(y = after_stat(density)),
bins = 50, fill = 'skyblue', color = 'blue') +
labs(title = input_title,
x = 'y_T+1', y = 'Density') +
theme_minimal()
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
bayesian_mean <- mean(y_tPlus1_simulation)
bayesian_95_lowerBound <- quantile(y_tPlus1_simulation, 0.025)
bayesian_95_upperBound<- quantile(y_tPlus1_simulation, 0.975)
print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = y_tPlus1_simulation,
input_title = 'Bayesian prediction for y_T+1 using AR(2) model under the non-informative prior',
input_path = 'figures/c_hist.png')
t_prior <- raw[1:10,]
ar2_prior <- lm(formula = y_t ~ `y_lag1` + `y_lag2`,
data = t_prior)
ar2_prior_estimation <- summary(ar2_prior)
computeStudenttDensity <- function(input_x, input_m, input_c,input_DoF){
firstPart <- gamma((input_DoF+1)/2) / (gamma(input_DoF/2)*sqrt(input_DoF*pi))
secondPart <- 1 / input_c
thirdPart <- (1 + 1/input_DoF * (input_x-input_m)^2 / input_c^2) ^ -((input_DoF+1)/2)
density <- firstPart * secondPart * thirdPart
}
prior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_prior$coefficients[3],
input_c = ar2_prior_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_prior$df.residual)
posterior_density <- computeStudenttDensity(input_x = 0,
input_m = ar2_gdp$coefficients[3],
input_c = ar2_estimation$coefficients['y_lag2', 'Std. Error'],
input_DoF = ar2_gdp$df.residual)
posteriorOddsRatio <- posterior_density / prior_density
ar1_probability <- posteriorOddsRatio / (1+posteriorOddsRatio)
ar2_probability <- 1 / (1+posteriorOddsRatio)
ar_simulation <- function(input_numberOfSimulations,
input_y,
input_model,
input_modelEstimation){
hat_beta <- coef(input_model)
covarianceMatrix <- input_modelEstimation$cov.unscaled
degreeOfFreedom <- input_model$df.residual
sizeOfSample <- length(input_model$model[['y_t']])
y_tPlus1_simulation <- numeric(input_numberOfSimulations)
for (i in 1:input_numberOfSimulations){
beta_i <- rmvt(n = 1,
sigma = covarianceMatrix,
df = degreeOfFreedom,
delta = hat_beta, type = 'shifted')
beta_i <- as.numeric(beta_i)        # length p
beta_i <- matrix(beta_i, ncol = 1)
y <- input_model$model[['y_t']]
X <- model.matrix(input_model)
residual <- y - X %*% beta_i
this_scale <- 1/(1/2 * t(residual) %*% residual)
h_i <- rgamma(n = 1, shape = sizeOfSample/2 , scale = this_scale)
residuals_i <- rnorm(n = 1, mean = 0, sd = sqrt(1/h_i))
this_hat_y_tPlus1 <- sum(input_y * hat_beta)
y_tPlus1_simulation[i] <- this_hat_y_tPlus1 + residuals_i
}
return(y_tPlus1_simulation)
}
ar1_numberOfSimulations <- ar1_probability * numberOfSimulations
ar2_numberOfSimulations <- ar2_probability * numberOfSimulations
SDDR_df <- data.frame(Model = c('AR(1)','AR(2)'),
Density = c(prior_density,posterior_density),
Probability = c(ar1_probability,ar2_probability),
numberOfSimulations = c(ar1_numberOfSimulations, ar2_numberOfSimulations),
posteriorOddsRatio = posteriorOddsRatio)
SDDR_df
ar1_result <- ar_simulation(
input_numberOfSimulations = ar1_numberOfSimulations,
input_y = this_y,
input_model = ar2_prior,
input_modelEstimation = ar2_prior_estimation)
ar2_result <- ar_simulation(
input_numberOfSimulations = ar2_numberOfSimulations,
input_y = this_y,
input_model = ar2_gdp,
input_modelEstimation = ar2_estimation)
BMA_simulationResults <- c(ar1_result, ar2_result)
bayesian_mean <- mean(BMA_simulationResults)
bayesian_95_lowerBound <- quantile(BMA_simulationResults, 0.025)
bayesian_95_upperBound<- quantile(BMA_simulationResults, 0.975)
print('Bayesian prediction:')
cat(sprintf('The prediction of y_{t+1} is %.4f.\n', bayesian_mean))
cat(sprintf('95%% prediction interval is [%.4f, %.4f].\n',
bayesian_95_lowerBound,
bayesian_95_upperBound))
distributionPlot(input_x = BMA_simulationResults,
input_title = 'Bayesian prediction for y_T+1 using Bayesian Model Averaging (BMA) with the AR(1) and AR(2) models',
input_path = 'figures/d_hist.png')
