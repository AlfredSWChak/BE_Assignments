geom_hline(yintercept = 0, color = 'black', linetype = 'dashed', linewidth = 1) +
labs(title = 'Daily returns of the S&P 500 in the six years 2018-2023',
x = 'Date', y = 'Daily returns') +
theme_minimal()
ggsave('figures/a_returns_plot.png', width = 10, height = 6, dpi = 300)
numberOfSimulations <- 1100
numberOfBurnIn <- 100
initial_alpha <- 0.4745
b_stdev <- 0.0275
logLikelihood <- function(input_alpha){
n <- length(input_returns)
s_squared <- var(input_returns)
result <- sum(sapply(2:n, function(j)
-1/2 * log(2*pi * (s_squared * (1-input_alpha) + input_alpha * input_returns[j-1]^2))
-1/2 * (input_returns[j]^2 / (s_squared * (1-input_alpha) + input_alpha * input_returns[j-1]^2))))
return (result)
}
metropolisHastings_method_norm <- function (input_stdev){
alpha_list <- numeric(numberOfSimulations)
acceptanceRate <- numeric(numberOfSimulations)
for (i in 1:numberOfSimulations) {
# draw from Normal distribution
if(i == 1){
this_alpha <- rnorm(n = 1, mean = initial_alpha, sd = input_stdev)
} else{
this_alpha <- rnorm(n = 1, mean = alpha_list[i-1], sd = input_stdev)
}
if (this_alpha < 0 || this_alpha > 1) {
acceptance = 0
} else {
if(i == 1){
acceptance = 1
} else {
logLikelihood_this <- logLikelihood(this_alpha)
logLikelihood_previous <- logLikelihood(alpha_list[i-1])
acceptance = min(1, exp(logLikelihood_this - logLikelihood_previous))
}
}
u <- runif(1, min = 0, max = 1)
if (u <= acceptance){
alpha_list[i] <- this_alpha
acceptanceRate[i] <- 1
} else {
if(i == 1){
alpha_list[i] <- initial_alpha
} else{
alpha_list[i] <- alpha_list[i-1]
}
acceptanceRate[i] <- 0
}
}
acceptancePercentage <- mean(acceptanceRate[(numberOfBurnIn+1):numberOfSimulations]) * 100
return (list(alpha=alpha_list, rate=acceptancePercentage))
}
b_result <- metropolisHastings_method_norm(b_stdev)
alpha_list_afterBurn <- b_result$alpha[(numberOfBurnIn+1):length(b_result$alpha)]
informationTable <- function(input_alpha){
alpha_mean <- mean(input_alpha)
alpha_stdev <- sd(input_alpha)
alpha_corr <- acf(input_alpha, lag.max = 1, plot = FALSE)$acf[2]
alpha_df <- data.frame(Parameters = c('α'),
PosteriorMean = c(alpha_mean),
PosteriorStdev = c(alpha_stdev),
serialCorrelation = c(alpha_corr))
return(alpha_df)
}
print(paste('Acceptance percentage: ',b_result$rate,'%'))
accepted_df <- informationTable(b_result$alpha)
accepted_df
tracePlot <- function (input_x, input_title, input_path){
plot_df <- data.frame(x = seq_along(input_x), y = input_x)
ggplot(plot_df, aes(x = x, y = y)) +
geom_line(color = 'blue') +
geom_vline(xintercept = initial_alpha, color = 'black', linetype = 'dashed', linewidth = 1) +
labs(title = input_title,
x = 'Iteration', y = 'Alpha') +
theme_minimal()
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
distributionPlot <- function (input_x, input_title, input_path){
plot_df <- data.frame(x = seq_along(input_x), y = input_x)
ggplot(plot_df, aes(x = y)) +
geom_histogram(aes(y = after_stat(density), color = 'Empirical Distribution'),
bins = 50, fill = 'skyblue') +
stat_function(fun = dnorm,
args = list(mean = mean(plot_df$y), sd = sd(plot_df$y)),
aes(color = 'Normal Distribution')
, linewidth = 1, linetype = 'dashed') +
geom_vline(aes(xintercept = initial_alpha, color = "Initial α"),
linetype = 'dashed', linewidth = 1) +
labs(title = input_title,
x = 'α', y = 'Density') +
theme_minimal() +
scale_color_manual(name   = 'Component',
values = c('Empirical Distribution' = 'blue',
'Normal Distribution' = 'red',
'Initial α' = 'black'))
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
tracePlot(alpha_list_afterBurn, 'Trace plot of draws α', 'figures/b_alpha_trace.png')
distributionPlot(alpha_list_afterBurn, 'Distribution of draws α', 'figures/b_alpha_hist.png')
c_stdev <- 0.002
c_result <- metropolisHastings_method_norm(c_stdev)
print(paste('Acceptance percentage: ',c_result$rate,'%'))
accepted_df <- informationTable(c_result$alpha)
accepted_df
alpha_list_afterBurn <- c_result$alpha[(numberOfBurnIn+1):length(c_result$alpha)]
tracePlot(alpha_list_afterBurn, 'Trace plot of draws α', 'figures/c_alpha_trace.png')
distributionPlot(alpha_list_afterBurn, 'Distribution of draws α', 'figures/c_alpha_hist.png')
d_stdev <- 6
d_result <- metropolisHastings_method_norm(d_stdev)
print(paste('Acceptance percentage: ',d_result$rate,'%'))
accepted_df <- informationTable(d_result$alpha)
accepted_df
alpha_list_afterBurn <- d_result$alpha[(numberOfBurnIn+1):length(d_result$alpha)]
tracePlot(alpha_list_afterBurn, 'Trace plot of draws α', 'figures/d_alpha_trace.png')
distributionPlot(alpha_list_afterBurn, 'Distribution of draws α', 'figures/d_alpha_hist.png')
logLikelihood_bivariate <- function(input_alpha, input_beta){
n <- length(input_returns)
s_squared <- var(input_returns)
variance <- numeric(n)
variance[1] <- s_squared * (1-input_alpha-input_beta)
for (i in 2:n){
variance[i] <- s_squared * (1-input_alpha-input_beta)
+ input_alpha * input_returns[i-1]^2
+ input_beta * variance[i-1]
}
result <- sum(sapply(2:n, function(j)
-1/2 * log(2*pi * (s_squared * (1-input_alpha-input_beta)
+ input_alpha * input_returns[j-1]^2
+ input_beta * variance[j-1]))
-1/2 * (input_returns[j]^2 / (s_squared * (1-input_alpha-input_beta)
+ input_alpha * input_returns[j-1]^2
+ input_beta * variance[j-1]))))
return (result)
}
metropolisHastings_method_bivariate_norm <- function(input_initial_theta, input_var_cov_matrix){
theta <- matrix(NA, nrow = numberOfSimulations,
ncol = 2)   # columns: alpha, beta
theta_candidate <- matrix(NA, nrow = numberOfSimulations, ncol = 2)
theta[1, ] <- input_initial_theta
theta_candidate[1, ] <- input_initial_theta
acceptanceRate <- numeric(numberOfSimulations)
for (i in 2:numberOfSimulations) {
# draw candidate from bivariate normal candidate distribution
theta_hat <- MASS::mvrnorm(1, mu = theta[i-1, ],
Sigma = input_var_cov_matrix)
this_alpha <- theta_hat[1]
this_beta <- theta_hat[2]
last_alpha <- theta[i-1,][1]
last_beta <- theta[i-1,][2]
if (this_alpha < 0 || this_beta < 0 || this_alpha + this_beta >= 1) {
acceptance <- 0
} else {
loglikelihood_posterior_hat <- logLikelihood_bivariate(this_alpha, this_beta)
loglikelihood_posterior_previous <- logLikelihood_bivariate(last_alpha, last_beta)
acceptance <- min(1, exp(loglikelihood_posterior_hat
- loglikelihood_posterior_previous))
}
u <- runif(1, min = 0, max = 1)
if (u <= acceptance){
theta[i,] <- theta_hat
acceptanceRate[i] <- 1
} else {
theta[i,] <- theta[i-1,]
acceptanceRate[i] <- 0
}
theta_candidate[i,] <- theta_hat
}
acceptancePercentage <- mean(acceptanceRate[(numberOfBurnIn+1):numberOfSimulations]) * 100
return (list(theta=theta, candidate=theta_candidate,
rate=acceptancePercentage))
}
initial_theta <- c(0.1817,0.7899)
var_cov_matrix <- matrix(c(0.000430, -0.000510,
-0.000510, 0.000626), nrow = 2, byrow = TRUE)
posterior <- metropolisHastings_method_bivariate_norm(initial_theta, var_cov_matrix)
# posterior estimations
theta_posterior <- posterior$theta[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_posterior <- theta_posterior[, 1]
beta_posterior  <- theta_posterior[, 2]
informationTable_bivariate <- function(input_alpha, input_beta){
alpha_mean <- mean(input_alpha)
alpha_stdev <- sd(input_alpha)
beta_mean <- mean(input_beta)
beta_stdev <- sd(input_beta)
alpha_corr <- acf(input_alpha, lag.max = 1, plot = FALSE)$acf[2]
beta_corr <- acf(input_beta, lag.max = 1, plot = FALSE)$acf[2]
alpha_beta_df <- data.frame(Parameters = c('α','β'),
PosteriorMean = c(alpha_mean, beta_mean),
PosteriorStdev = c(alpha_stdev, beta_stdev),
serialCorrelation = c(alpha_corr,beta_corr))
return(alpha_beta_df)
}
print(paste('Acceptance percentage: ',posterior$rate,'%'))
accepted_df <- informationTable_bivariate(alpha_posterior, beta_posterior)
accepted_df
draw_scatterPlot <- function(input_x, input_y, input_title, input_path){
scatter_df <- data.frame(x = input_x, y = input_y)
ggplot(scatter_df, aes(x = x, y = y)) +
geom_point(color = 'blue') +
labs(title = input_title,
x = 'α', y = 'Density') +
theme_minimal()
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
tracePlot(alpha_posterior,'Trace plot of draws α','figures/e_alpha_trace.png')
tracePlot(beta_posterior,'Trace plot of draws β','figures/e_beta_trace.png')
# scatter plot of (accepted and repeated) draws of α and β
draw_scatterPlot(input_x = alpha_posterior,
input_y = beta_posterior,
input_title = 'Scatter plot of draws of α and β',
input_path = 'figures/e_accepted_scatter.png')
theta_candidate_posterior <- posterior$candidate[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_candidate_posterior <- theta_candidate_posterior[, 1]
beta_candidate_posterior  <- theta_candidate_posterior[, 2]
candidate_df <- informationTable_bivariate(alpha_candidate_posterior,
beta_candidate_posterior)
candidate_df
# scatter plot of candidate draws of α and β
draw_scatterPlot(input_x = alpha_candidate_posterior,
input_y = beta_candidate_posterior,
input_title = 'Scatter plot of candidate draws of α and β',
input_path = 'figures/e_candidate_scatter.png')
initial_theta <- c(0.1817,0.7899)
var_cov_matrix <- matrix(c(0.000430, 0,
0, 0.000626), nrow = 2, byrow = TRUE)
posterior <- metropolisHastings_method_bivariate_norm(initial_theta, var_cov_matrix)
# posterior estimations
theta_posterior <- posterior$theta[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_posterior <- theta_posterior[, 1]
beta_posterior  <- theta_posterior[, 2]
print(paste('Acceptance percentage: ',posterior$rate,'%'))
accepted_df <- informationTable_bivariate(alpha_posterior, beta_posterior)
accepted_df
tracePlot(alpha_posterior,'Trace plot of draws α','figures/f_alpha_trace.png')
tracePlot(beta_posterior,'Trace plot of draws β','figures/f_beta_trace.png')
# scatter plot of (accepted and repeated) draws of α and β
draw_scatterPlot(input_x = alpha_posterior,
input_y = beta_posterior,
input_title = 'Scatter plot of draws of α and β',
input_path = 'figures/f_accepted_scatter.png')
theta_candidate_posterior <- posterior$candidate[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_candidate_posterior <- theta_candidate_posterior[, 1]
beta_candidate_posterior  <- theta_candidate_posterior[, 2]
candidate_df <- informationTable_bivariate(alpha_candidate_posterior,
beta_candidate_posterior)
candidate_df
# scatter plot of candidate draws of α and β
draw_scatterPlot(input_x = alpha_candidate_posterior,
input_y = beta_candidate_posterior,
input_title = 'Scatter plot of candidate draws of α and β',
input_path = 'figures/f_candidate_scatter.png')
library(ggplot2)
rawData <- read.csv('Assignment2Dataset.csv')
input_returns <- rawData[[1]]
df <- data.frame(date = seq_along(input_returns), returns = input_returns)
ggplot(df, aes(x = date, y = returns)) +
geom_line(color = 'blue') +
geom_hline(yintercept = 0, color = 'black', linetype = 'dashed', linewidth = 1) +
labs(title = 'Daily returns of the S&P 500 in the six years 2018-2023',
x = 'Date', y = 'Daily returns') +
theme_minimal()
ggsave('figures/a_returns_plot.png', width = 10, height = 6, dpi = 300)
numberOfSimulations <- 1100
numberOfBurnIn <- 100
initial_alpha <- 0.4745
b_stdev <- 0.0275
logLikelihood <- function(input_alpha){
n <- length(input_returns)
s_squared <- var(input_returns)
result <- sum(sapply(2:n, function(j)
-1/2 * log(2*pi * (s_squared * (1-input_alpha) + input_alpha * input_returns[j-1]^2))
-1/2 * (input_returns[j]^2 / (s_squared * (1-input_alpha) + input_alpha * input_returns[j-1]^2))))
return (result)
}
metropolisHastings_method_norm <- function (input_stdev){
alpha_list <- numeric(numberOfSimulations)
acceptanceRate <- numeric(numberOfSimulations)
for (i in 1:numberOfSimulations) {
# draw from Normal distribution
if(i == 1){
this_alpha <- rnorm(n = 1, mean = initial_alpha, sd = input_stdev)
} else{
this_alpha <- rnorm(n = 1, mean = alpha_list[i-1], sd = input_stdev)
}
if (this_alpha < 0 || this_alpha > 1) {
acceptance = 0
} else {
if(i == 1){
acceptance = 1
} else {
logLikelihood_this <- logLikelihood(this_alpha)
logLikelihood_previous <- logLikelihood(alpha_list[i-1])
acceptance = min(1, exp(logLikelihood_this - logLikelihood_previous))
}
}
u <- runif(1, min = 0, max = 1)
if (u <= acceptance){
alpha_list[i] <- this_alpha
acceptanceRate[i] <- 1
} else {
if(i == 1){
alpha_list[i] <- initial_alpha
} else{
alpha_list[i] <- alpha_list[i-1]
}
acceptanceRate[i] <- 0
}
}
acceptancePercentage <- mean(acceptanceRate[(numberOfBurnIn+1):numberOfSimulations]) * 100
return (list(alpha=alpha_list, rate=acceptancePercentage))
}
b_result <- metropolisHastings_method_norm(b_stdev)
alpha_list_afterBurn <- b_result$alpha[(numberOfBurnIn+1):length(b_result$alpha)]
informationTable <- function(input_alpha){
alpha_mean <- mean(input_alpha)
alpha_stdev <- sd(input_alpha)
alpha_corr <- acf(input_alpha, lag.max = 1, plot = FALSE)$acf[2]
alpha_df <- data.frame(Parameters = c('α'),
PosteriorMean = c(alpha_mean),
PosteriorStdev = c(alpha_stdev),
serialCorrelation = c(alpha_corr))
return(alpha_df)
}
print(paste('Acceptance percentage: ',b_result$rate,'%'))
accepted_df <- informationTable(b_result$alpha)
accepted_df
tracePlot <- function (input_x, input_title, input_path){
plot_df <- data.frame(x = seq_along(input_x), y = input_x)
ggplot(plot_df, aes(x = x, y = y)) +
geom_line(color = 'blue') +
geom_vline(xintercept = initial_alpha, color = 'black', linetype = 'dashed', linewidth = 1) +
labs(title = input_title,
x = 'Iteration', y = 'Alpha') +
theme_minimal()
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
distributionPlot <- function (input_x, input_title, input_path){
plot_df <- data.frame(x = seq_along(input_x), y = input_x)
ggplot(plot_df, aes(x = y)) +
geom_histogram(aes(y = after_stat(density), color = 'Empirical Distribution'),
bins = 50, fill = 'skyblue') +
stat_function(fun = dnorm,
args = list(mean = mean(plot_df$y), sd = sd(plot_df$y)),
aes(color = 'Normal Distribution')
, linewidth = 1, linetype = 'dashed') +
geom_vline(aes(xintercept = initial_alpha, color = "Initial α"),
linetype = 'dashed', linewidth = 1) +
labs(title = input_title,
x = 'α', y = 'Density') +
theme_minimal() +
scale_color_manual(name   = 'Component',
values = c('Empirical Distribution' = 'blue',
'Normal Distribution' = 'red',
'Initial α' = 'black'))
ggsave(input_path, width = 10, height = 5, dpi = 300)
}
tracePlot(alpha_list_afterBurn, 'Trace plot of draws α', 'figures/b_alpha_trace.png')
distributionPlot(alpha_list_afterBurn, 'Distribution of draws α', 'figures/b_alpha_hist.png')
c_stdev <- 0.002
c_result <- metropolisHastings_method_norm(c_stdev)
print(paste('Acceptance percentage: ',c_result$rate,'%'))
accepted_df <- informationTable(c_result$alpha)
accepted_df
alpha_list_afterBurn <- c_result$alpha[(numberOfBurnIn+1):length(c_result$alpha)]
tracePlot(alpha_list_afterBurn, 'Trace plot of draws α', 'figures/c_alpha_trace.png')
distributionPlot(alpha_list_afterBurn, 'Distribution of draws α', 'figures/c_alpha_hist.png')
d_stdev <- 6
d_result <- metropolisHastings_method_norm(d_stdev)
print(paste('Acceptance percentage: ',d_result$rate,'%'))
accepted_df <- informationTable(d_result$alpha)
accepted_df
alpha_list_afterBurn <- d_result$alpha[(numberOfBurnIn+1):length(d_result$alpha)]
tracePlot(alpha_list_afterBurn, 'Trace plot of draws α', 'figures/d_alpha_trace.png')
distributionPlot(alpha_list_afterBurn, 'Distribution of draws α', 'figures/d_alpha_hist.png')
logLikelihood_bivariate <- function(input_alpha, input_beta){
n <- length(input_returns)
s_squared <- var(input_returns)
variance <- numeric(n)
variance[1] <- s_squared * (1-input_alpha-input_beta)
for (i in 2:n){
variance[i] <- s_squared * (1-input_alpha-input_beta)
+ input_alpha * input_returns[i-1]^2
+ input_beta * variance[i-1]
}
result <- sum(sapply(2:n, function(j)
-1/2 * log(2*pi * (s_squared * (1-input_alpha-input_beta)
+ input_alpha * input_returns[j-1]^2
+ input_beta * variance[j-1]))
-1/2 * (input_returns[j]^2 / (s_squared * (1-input_alpha-input_beta)
+ input_alpha * input_returns[j-1]^2
+ input_beta * variance[j-1]))))
return (result)
}
metropolisHastings_method_bivariate_norm <- function(input_initial_theta, input_var_cov_matrix){
theta <- matrix(NA, nrow = numberOfSimulations,
ncol = 2)   # columns: alpha, beta
theta_candidate <- matrix(NA, nrow = numberOfSimulations, ncol = 2)
theta[1, ] <- input_initial_theta
theta_candidate[1, ] <- input_initial_theta
acceptanceRate <- numeric(numberOfSimulations)
for (i in 2:numberOfSimulations) {
# draw candidate from bivariate normal candidate distribution
theta_hat <- MASS::mvrnorm(1, mu = theta[i-1, ],
Sigma = input_var_cov_matrix)
this_alpha <- theta_hat[1]
this_beta <- theta_hat[2]
last_alpha <- theta[i-1,][1]
last_beta <- theta[i-1,][2]
if (this_alpha < 0 || this_beta < 0 || this_alpha + this_beta >= 1) {
acceptance <- 0
} else {
loglikelihood_posterior_hat <- logLikelihood_bivariate(this_alpha, this_beta)
loglikelihood_posterior_previous <- logLikelihood_bivariate(last_alpha, last_beta)
acceptance <- min(1, exp(loglikelihood_posterior_hat
- loglikelihood_posterior_previous))
}
u <- runif(1, min = 0, max = 1)
if (u <= acceptance){
theta[i,] <- theta_hat
acceptanceRate[i] <- 1
} else {
theta[i,] <- theta[i-1,]
acceptanceRate[i] <- 0
}
theta_candidate[i,] <- theta_hat
}
acceptancePercentage <- mean(acceptanceRate[(numberOfBurnIn+1):numberOfSimulations]) * 100
return (list(theta=theta, candidate=theta_candidate,
rate=acceptancePercentage))
}
initial_theta <- c(0.1817,0.7899)
var_cov_matrix <- matrix(c(0.000430, -0.000510,
-0.000510, 0.000626), nrow = 2, byrow = TRUE)
posterior <- metropolisHastings_method_bivariate_norm(initial_theta, var_cov_matrix)
# posterior estimations
theta_posterior <- posterior$theta[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_posterior <- theta_posterior[, 1]
beta_posterior  <- theta_posterior[, 2]
informationTable_bivariate <- function(input_alpha, input_beta){
alpha_mean <- mean(input_alpha)
alpha_stdev <- sd(input_alpha)
beta_mean <- mean(input_beta)
beta_stdev <- sd(input_beta)
alpha_corr <- acf(input_alpha, lag.max = 1, plot = FALSE)$acf[2]
beta_corr <- acf(input_beta, lag.max = 1, plot = FALSE)$acf[2]
alpha_beta_df <- data.frame(Parameters = c('α','β'),
PosteriorMean = c(alpha_mean, beta_mean),
PosteriorStdev = c(alpha_stdev, beta_stdev),
serialCorrelation = c(alpha_corr,beta_corr))
return(alpha_beta_df)
}
print(paste('Acceptance percentage: ',posterior$rate,'%'))
accepted_df <- informationTable_bivariate(alpha_posterior, beta_posterior)
accepted_df
draw_scatterPlot <- function(input_x, input_y, input_title, input_path){
scatter_df <- data.frame(x = input_x, y = input_y)
ggplot(scatter_df, aes(x = x, y = y)) +
geom_point(color = 'blue') +
labs(title = input_title,
x = 'α', y = 'Density') +
theme_minimal()
ggsave(input_path, width = 6, height = 6, dpi = 300)
}
tracePlot(alpha_posterior,'Trace plot of draws α','figures/e_alpha_trace.png')
tracePlot(beta_posterior,'Trace plot of draws β','figures/e_beta_trace.png')
# scatter plot of (accepted and repeated) draws of α and β
draw_scatterPlot(input_x = alpha_posterior,
input_y = beta_posterior,
input_title = 'Scatter plot of draws of α and β',
input_path = 'figures/e_accepted_scatter.png')
theta_candidate_posterior <- posterior$candidate[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_candidate_posterior <- theta_candidate_posterior[, 1]
beta_candidate_posterior  <- theta_candidate_posterior[, 2]
candidate_df <- informationTable_bivariate(alpha_candidate_posterior,
beta_candidate_posterior)
candidate_df
# scatter plot of candidate draws of α and β
draw_scatterPlot(input_x = alpha_candidate_posterior,
input_y = beta_candidate_posterior,
input_title = 'Scatter plot of candidate draws of α and β',
input_path = 'figures/e_candidate_scatter.png')
initial_theta <- c(0.1817,0.7899)
var_cov_matrix <- matrix(c(0.000430, 0,
0, 0.000626), nrow = 2, byrow = TRUE)
posterior <- metropolisHastings_method_bivariate_norm(initial_theta, var_cov_matrix)
# posterior estimations
theta_posterior <- posterior$theta[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_posterior <- theta_posterior[, 1]
beta_posterior  <- theta_posterior[, 2]
print(paste('Acceptance percentage: ',posterior$rate,'%'))
accepted_df <- informationTable_bivariate(alpha_posterior, beta_posterior)
accepted_df
tracePlot(alpha_posterior,'Trace plot of draws α','figures/f_alpha_trace.png')
tracePlot(beta_posterior,'Trace plot of draws β','figures/f_beta_trace.png')
# scatter plot of (accepted and repeated) draws of α and β
draw_scatterPlot(input_x = alpha_posterior,
input_y = beta_posterior,
input_title = 'Scatter plot of draws of α and β',
input_path = 'figures/f_accepted_scatter.png')
theta_candidate_posterior <- posterior$candidate[(numberOfBurnIn+1):numberOfSimulations, ]
alpha_candidate_posterior <- theta_candidate_posterior[, 1]
beta_candidate_posterior  <- theta_candidate_posterior[, 2]
candidate_df <- informationTable_bivariate(alpha_candidate_posterior,
beta_candidate_posterior)
candidate_df
# scatter plot of candidate draws of α and β
draw_scatterPlot(input_x = alpha_candidate_posterior,
input_y = beta_candidate_posterior,
input_title = 'Scatter plot of candidate draws of α and β',
input_path = 'figures/f_candidate_scatter.png')
